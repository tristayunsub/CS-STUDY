프로세서. cpu를 구현하는 방식 명령어 instruction 실행 방식의 측면에서 네 가지로 구분.

중요한거 두가지 sequential implementation, pipelined implementation. 두 방식에 대한 설명은 포스팅에서.

참고로 밑으로 갈수록 cpu의 성능은 향상되지만, 올바른 동작인가에 대한 의문은 더 커진다.

성능을 높이기 위한 복잡한 구현은 버그를 만들어낼수도있기때문.

sequenntial-> 한 instruction이 완전히 끝난 다음 명령어 수행

pipelined 한 instruction이 완전히 끝나기 전에 다음 instruction 을 수행하기 시작하는것.

out of order execution 그냥 바로 instruction을 시작하는것.



2-2. 캐시 메모리
메인메모리 DRAM(Dynamic Ram)으로, 캐시 메모리(STATIC RAM)으로 만들어진다.

DRAM은 상대적으로 속도가 느리지만, 단위 용량 가격이 저렴하기 떄문에, 용량이 큰 메인 메모리르 만들때 사용.

SRAM은 속도가 빠르지만 상대적으로 가격이 비쌈 

CPU는 메모리에 접근하고자 할때 먼저 캐시 메모리부터 확인. 찾고자하는 데이터가 캐시 메모리에서 발견되면 HIT, 그렇지않으면 MISS
다

그렇다면 HIT 확률은? 현대 CPU들은 캐시 HIT 확률이 95프로. LOCALITY

지역성.  TEMPORAL LOCALITY. 어떤 데이터를 참조하면 가까운 미래에 다시 참조

SPATIAL LOCALITY 어떤 데이터 참조하면 가까운 미래에 그 주변의 데이터를 참조함.


어떤 데이터의 참조에서 Miss가 발생하면 그 데이터를 포함하는 메인 메모리의 한 블록을 캐시 메모리에 저장한다.
이는 Spatial Locality를 활용한 것이다. 또한 캐시 메모리 내 블록들을 최근에 참조된 순서대로 정렬하고,
캐시 메모리가 꽉 차서 특정 블록을 버려야 하는 경우 가장 예전에 참조되었던 블록을 버리도록 한다. 이는 Temporal Locality를 활용한 것이다.





VIRTUALIZATION.


1.부팅이란? 이거 뭐 면접때나오기도함.

컴퓨터 전원을 켜면 어떠한 과정을 거쳐서 운영체제의 실행으로 까지 이어지는 것일까?.컴퓨터 전원 키는 순간, 실행할 명령어의 주소를 담고있는

PC레지스터의 값은 특정 값으로 초기화 됨. 그 값은 ISA에서 정의. OS를 실행하기전에 수행해야하는 몇몇 초기화 작업들을 위한 루틴의 시작 주소가 된다.

그러한 루틴은 ROM 혹은 NOR 플래시 메모리와 같은 휘발성 메모리에 저장되어있어, 컴퓨터의 전원이 꺼져있을때도 데이터가 계속 유지된다. 초기화 작업을 위한

루틴이 종료되면, 하드디스크에서 OS의 코드를 로드하여 실행한다. 이로써 부팅이 완료.. 어렵네..


레지스터값 이 특정 값으로 초기화->> OS 실행전에 초기화 작업을 위한 루틴의 시작주소가 됨. ->

루틴은 NOR 또는 ROM같은 플래시메모리에 저장됨. 초기화 작업 위한 루틴 종료되면, 


하드디스크에서 OS의 코드를 로드해서 실행.

가상화? 물리적한계를 뛰어넘는 기능을 제공하는것처럼 보이게하는 기술.


2.-1 프로세스 추상화 PROCESS ABSTRACTION

하나의 물리적인 CPU에 타이머 장치 인터럽트 이용한 시간분할다중화. 여러개 CPU가있는듯한 착각

가상머신.

캐시 메모리와 가상 메모리

DRAM으로 만들어진 메인 메모리에 SRAM으로 만들어진 캐시메모리를 더하여 속도는 SRAM만큼 빠르고, 가격은 DRAM만큼 저렴한 메모리가 있는것처럼 착각.

메인 메모리에서 자주 참조되는 데이터를 캐시 메모리에 저장 하고, CPU는 메모리 접근시 캐시 메모리를 먼저 확인함으로써

메모리 참조 속도를 혁신적으로 향상시킴


2-4 가상 메모리?

메인 메모리에 로드될 데이터를 하드디스크에 저장하고. 그중 프로세스가 자주 참조하는 부분 메인메모리 로드, 각각의 프로세서가 하나의 메인메모리를 독차지하는 듯한 착각.

이는 하드 디스크를 대상으로 공간 분할 다중화(Space Division Multiplexing) 기술을 적용한 사례라고 볼 수 있다

가상메모리가 매우 중요함. 

3-1 가상 주소? VIRTUAL ADDRESS, PHYSICAL ADDRESS

가상 주소 공간은 고정된 크기의 PAGE로 나눠진다. 그중 일부 페이지들만 물리 주소 공간의 페이지에 대응 되고 나머지 페이지들은 하드디스크에 저장.

이게 가상메모리의 핵심. CPU가 가상 주소를 MMU라는 하드웨어에 주면. MMU는 TLB (TRANSLATION LOOK ASIDE BUFFER)라는 하드웨어 장치를 참조하여

가상 주소를 물리 주소로 변환한다. TLB가 물리주소를 계산해내지 못하는경우. 이걸 페이지 폴트라고 한다.

가상주소의 공간의 페이지가 물리 주소 공간에 없기 때문에 발생.


글서 어떻게 구현?

하드웨어. MMU+PAGEFAULT를 처리하는 예외 메커니즘.

소프트웨어: 페이지 테이블에 근거하여 가상 메모리를 관리하는 OS 루틴

3-3-2. 어떤 원리로 최적화 진행?

메모리 참조는 두 종류의 지역성을 활용하여 최적화. 첫째로 TEMPORAL LOCALITY는 최근에 참조된 데이터가 다시 참조될 확률이 높다.

MMU가 가상주소를 물리주소로 변환할때 고속의 보조 기억 장치에 해당하는 TLB가 바로 그렇다. 캐시메모리와 마찬가지로 페이지 테이블 구성하여 페이지 폴트 발생확률 낮춤.

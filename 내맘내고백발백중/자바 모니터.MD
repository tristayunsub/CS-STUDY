자바 모니터란? https://www.youtube.com/watch?v=Dms1oBmRAlo&list=PLcXyemr8ZeoT-_8yBc_p_lVwRRqUaN8ET&index=6&ab_channel=%EC%89%AC%EC%9A%B4%EC%BD%94%EB%93%9C

자바 thread와 동기화 모니터라는 개념을 적용한다.

모니터란?

1.하나의 데이터(객체)마다 하나의 모니터를 결합 할 수 있으며, 모니터는 그것이 결합된 데이터가 동시에 두개 이상의 스레드에 접근 할 수 없도록 막는 잠금 기능을 제공함으로써

동기화를 수행함.

2.즉 데이터에 모니터를 결합하면 하나의 스레드가 그 데이터를 사용ㅇ하는 동안에는 다른 스레드들이 그 데이터를 사용할 수 없게 된다.

자바에서는. synchronized 메소드가 선언된 객체와 synchronized 블럭에 의해 동기화 되는 모든 객체에 고유한 모니터가 결합이 되어 동기화 작업을 수행


모니터ㅡ의 구성
스레드 단위로 모니터락을 획득하거나 aquire lock. 반환 release lock 한다.

동기화 코드(동기화 메소드나 블럭)을 수행할 때에는 동기화 대상 인스턴스와 결합된 monitor lock을 획득한 후에 진입가능하며, 동기화 코드를 벗어날 때에는
monitor lock을 반환하게 된다.

동기화 대상 인스턴스 별로 이와 결합된 monitor가 존재하며. 해당 모니터는 해당락을 획득한 스레드와 lock count 정보로 관리

모니터가 lock count를 유지한다는 것은 동일 스레드가 중복해서 lock을 걸수있다는 의미

monitor와 스레드 대기 자료구조 2가지.
모니터는 락을 획득하기 위해 시도하는 스레드를 대기시키기 위한 자료구조와 조건변수 conditional variable로서의 역할을 수행하기 위해 특정 조건이
만족될떄 까지. 스레드를 대기시키기 위한 자료구조를 가지고 있다.

1)Entry set. 진입셋
모니터 락을 기다리는 스레드를 담아두기 위한 자료구조.

2.wait set
모니터가 notify 해줄때까지 기다리는 스레드를 담는 자료구조


2.자바 모니터의 동작 과정 모니터락 획득 및 반환 과정

1.한 스레드가 동기화 코드 영역에 접근하기 위해 entry set에 진입 runnable 상태에서 -> blocked 상태로

2) 모니터락을 소유한 스레드가 있다면 해당 스레드가 모니터락을 반환할때 까지 entryset에서 대기한다.
3) blocked상태


3)모니터락을 소유한 스레드가 없다면, entryset에서 대기하던 스레드 중 하나의 스레드가 선택되어 모니터락을 획득하고 실행하게 된다.

동기화 코드 영역을 벗어나면서 소유한 모니터락을 반환
선택된 스레드:runnable, ㅅ나머지는 blocked


3.자바 모니터가 지원하는 동기화



자바 모니터는 다음 두가지 동기화를 지원해주고있다.

mutual exclusion 상호 배제
상호배제란 ㄷ둘 이상의 스레드가 임계영역에 동시에 접근 막ㄱ음

다수의 스레드가 데이터를 공유할때 서로 간섭없이 접근하고자 할떄 필요하다

동기화코드를 통해 동기화 대상 인스턴스의 lock을 얻은 스레드만이 임계영역에 접근가능. lock을얻지 못한 스레드는 entry set에서 대기했다가
다음기회에 lock을 얻기위해 경쟁.

cooperation 협력
모니터가 조건변수의 역할 수행. 멀티스레드 간 공유데이터의 동시접근을 막을 뿐만이 아니라 접근 순서도 컨트롤

같은 목적을 가진 스레드간에 협력해서 효율적으로 작업할 수 있도록 하겠다 라는 의미이다.

생산자-소비자 스레드를 생각하면. 단순히 상호배제만을 해서는 부족하다. 즉 동시접근도 차단하고 생산자 스레드가 생산을 했을때
소비자 스레드에게 이를 알려 작업할 수 있도록 해주는것이 필요


동기화 대상 인스턴스의 wait() / notify() / notifyall()메소드를 이용하여 스레드간 접근 순서 컨트롤을 수행할 수 있다.


```
#상호배제를 활용한 동기화 방식









```



두번째는 협업에 의한 동기화 방식.
1.협업을 하기 위한 동기화
스레드간의 접근순서를 동기화 하기 위해서는 object클래스에 정의되어있는 wait 및 notify 계약 메소드를 이용할 수 있다.

2.object클래스의 스레드 컨트롤 메소드를 살펴보자.

A. public final void wait() throws InterruptedExeption

다른 스레드가 대상 객체에 대하여 notify() 또는 notifyAll()메소드를 호출할 때까지 대기한다.

내부 처리과정을 살펴보면 다음과 같다.

wait()를 호출하려면, 먼저 동기화 대상 인스턴스에 결합된 모니터락을 소유하고 있어야 한다. 

즉 동기화 코드 영역내에 진입을 한 상태에서 호출하여야 한다. 그렇지 않으면 IIIegalMonitorStateException이 발생한다.

wait()를 호출한다는 의미는 "대상객체의 특정조건이 만족할 때까지 대기하겠다"라는 의미이므로 먼저 다른 스레드에 의해서 대상객체에 

어떤 작업을 수행 할 수 있도록 모니터락을 해제한다.

해당 모니터의 WaitSet(wait-pool)에 등록되어 대기한다.

다른 스레드에 의해 동기화 대상 인스턴스의 notify() 또는 notifyAll()메소드가 호출될 때까지 대기한다.

다른 스레드에 의해 notify() 또는 notifyAll()이 되면, 해당 모니터의 WaitSet에서 대기하던 스레드는 하나 또는 전체가 

EntrySet으로 이동한 후, notify를 호출한 스레드가 모니터락을 반환하게 되면 EntrySet에서 대기하던 스레드들은 모니터락을 얻기 위해 경쟁한다.


B. public final void wait(long timeout) throws InterruptedException

다른 스레드에 의해 notify될 때까지 지정한 시간동안 현재 스레드를 대기시키는 메소드


public final notify
소유한 모니터락의 waitset에서 대기중인 스레드중 하나의 스레드를 실행가능하도록 깨워준다.
좀더 정확히말하면. 소유한 모니터락의 waitset에 대기하고있던 스레드중 하나의 스레드를 모니터의 entryset으로 이동
그 이후에 notify를 호출한 스레드가 모니터락을 반환.. entryset에서 대기중이던 스레드들이 경합 하나의 스레드가 모니터 락을 획득.

public final void notifyAll


개중요 ---

wait/notify계열 메소드사용시 주의할 점

A. 스레드가 wait()를 한다는 것은 특정 조건이 만족이 될 때까지 기다리겠다 라는 의미이다. 
그런데 현재 모니터를 소유한 스레드가 notify(or notifyAll)를 해 준다는 것은 WAITING하고 있는 스레드에게 원하는 상태가 되었다는 확인이 아니라 
그러한 상태가 되었을 것이라는 힌트를 주는 것에 불과하다는 사실이다. 이게 무슨말인고 하니, 
특정조건을 만족시켜 notify/notifyAll을 한다고 해도 WAITING스레드 뿐만이 아니라 BLOCKED스레드가 함께 경쟁을 하면서 모니터락을 획득하려고 시도를 하는데, 
스레드가 모니터락을 획득했을 때 여전히 그 조건이 만족되는지는 확인을 해 보지 않는 한 알 수 없다 라는 의미이다.

B. 따라서 wait()메소드를 호출할 때에는 "반드시 loop문으로 구성"하여 wait()메소드에서 빠져 나올 때 원하는 조건 상태가 되어 있는지 
반복적으로 체크를 하도록 해 주어야 한다.



---

wait/notify  계열 메소드사용시 주의할점.


